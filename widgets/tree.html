<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skill Tree</title>
    <style>
        canvas {
            border: 1px solid black;
            background-color: #f0f0f0;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1200" height="600"></canvas>
    <script>

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        window.onload = init;
        
        var panning = false;
        var lastMousePos = {x:0,y:0};
        var cameraOffset = {x:0,y:0};
        var position = [{x:400,y:500}];
        var level = [1];
        var resources = [0];
        var currCosts = [[[0,10]]];
        var scaling = [[[0,"+10"]]];

        var nodeSize = 50;
        var cellSize = 50;

        var ticks = 0;
        var tickCalc = 60;

        var state = 0;
        var grid = [[]];
        var gridSize = [8,8];
        var cellsRemaining = gridSize[0]*gridSize[1];
        var cellValue = 1;

        
        function init() {
            window.requestAnimationFrame(draw);
        }
        
        function draw() {
            loop();
            window.requestAnimationFrame(draw);
        }

        function pointWithin(mx,my,x,y,w,h) {
            return (Math.abs(mx - cameraOffset.x - x) <= w && Math.abs(my - cameraOffset.y - y) <= h);
        }

        const rect = canvas.getBoundingClientRect();

        addEventListener('mousemove', function (e) {
            if (panning) {
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const offsetX = mouseX - lastMousePos.x;
                const offsetY = mouseY - lastMousePos.y;

                cameraOffset.x += offsetX;
                cameraOffset.y += offsetY;

                lastMousePos.x = mouseX;
                lastMousePos.y = mouseY;
            };
        });
        
        addEventListener('mousedown', function (e) {
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (e.button == 2 || (e.button == 0 && e.shiftKey)) { // right click (panning)
                console.log("panning");
                panning = true;

                lastMousePos.x = mouseX;
                lastMousePos.y = mouseY;
            }

            if (e.button == 0) {
                console.log(mouseX, mouseY);
                
                // console.log(position[0].x + cameraOffset.x, position[0].y + cameraOffset.y);
                for (let node = 0; node < level.length; node++) {
                    if (pointWithin(mouseX, mouseY, position[node].x, position[node].y, nodeSize/2, nodeSize/2)) {

                        nodeClicked(node);
                    }
                }
            }
        });

        addEventListener('mouseup', function (e) {
            if (state == 1) { // skill tree
                if (panning) { // right click (panning)
                    console.log("stopped panning")
                    panning = false;
                }
            }
        });
    
        addEventListener('keyup', function (e) {
            if (state == 1) { // skill tree 
                // console.log(e);
                if (e.key == "Shift" && panning) {
                    console.log("stopped panning")
                    panning = false;
                }
            }
            if (e.key == "p") {
                console.log(cameraOffset);
            }
            if (e.key == " ") {
                state = (state + 1)&1;
            }
        });


        function loop() { // main game loop
            render();
            drawUI();
            calculate();
        }

        function render() { // rendering 
            clearCanvas();
            if (state == 0) { // main game state
                for (let row = 0; row < grid.length; row++) {
                    for (let col = 0; col < grid[row].length; col++) {
                        ctx.fillStyle = 'gray';
                        ctx.fillRect(50 + col*cellSize, 50 + row*cellSize, cellSize, cellSize);
                    }
                }
            }

            if (state == 1) { // skill tree 
                for (let node = 0; node < level.length; node++) {
                    ctx.fillStyle = 'green';
                    ctx.fillRect(position[node].x + cameraOffset.x - nodeSize/2, 
                        position[node].y + cameraOffset.y - nodeSize/2, nodeSize, nodeSize);
                    ctx.fillStyle = 'black';
                    ctx.font = '14px Arial';
                    ctx.fillText("Lv." + level[node], position[node].x + cameraOffset.x - nodeSize/4, position[node].y + cameraOffset.y);
                    ctx.fillText("Cost: " + currCosts[node], position[node].x + cameraOffset.x - nodeSize/4, position[node].y + cameraOffset.y + 10);
                }
                // ctx.fillRect(cameraOffset.x, cameraOffset.y, 50, 50);
                // ctx.fillStyle = 'black';
                // ctx.fillRect(400, 500, 5, 5);
            }
        }

        function drawUI() {
            ctx.fillStyle = 'black';
            ctx.font = '30px Arial'
            for (let i = 0; i < level.length; i++) {
                if (i == 0) {
                    ctx.fillText("Basic: " + resources[i], 20, 50);
                }
            }
        }


        function nodeClicked(node) {
            if (attemptUpgrade(node)) {
                console.log("Upgraded node " + node + ".");
                level[node] += 1;
                
                // change costs here 
                for (let i = 0; i < currCosts[node].length; i++) {
                    resources[currCosts[node][i][0]] -= currCosts[node][i][1];
                    for (let groups = 0; groups < scaling[node].length; groups++) {
                        curr = scaling[node][groups][1].split(" ")
                        for (let group = 0; group < curr.length; group++) {
                            console.log(currCosts[node][group], curr, curr[group], curr[group][0]);
                            if (curr[group][0] === "+") currCosts[node][i][1] += Number(curr[group].substr(1));
                            if (curr[group][0] === "*") currCosts[node][i][1] *= Number(curr[group].substr(1));
                            if (curr[group][0] === "^") currCosts[node][i][1] = Math.pow(resources[currCosts[node][i][0]], Number(curr[group].substr(1)));

                        }
                    }
                }



            } else console.log("Could not afford!");
        }

        function canAfford(node) {
            for (let i = 0; i < currCosts[node].length; i++) {
                if (resources[currCosts[node][i][0]] < currCosts[node][i][1]) return false;
            }
            return true;
        }

        function attemptUpgrade(node) {
            if (level[node] < 1) return false;
            return canAfford(node);
        }


        function calculate() {
            if (state == 0) { // main game 
                if (cellsRemaining == 0) {
                    grid = Array.from(Array(gridSize[0]), () => Array.from(gridSize[1]), () => ++cellValue);
                    cellsRemaining = gridSize[0] * gridSize[1];
                    
                }
            }
            if (state == 1) { // skill tree passive gain
                if (ticks++ >= tickCalc) {
                    ticks -= tickCalc;
                    for (let i = 0; i < level.length; i++) {
                        resources[i] += level[i];
                    }
                }
            }
        }

        // Function to clear canvas
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }



    </script>
</body>
</html>