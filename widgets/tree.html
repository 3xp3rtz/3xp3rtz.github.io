<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skill Tree</title>
    <style>
        canvas {
            border: 1px solid black;
            background-color: #f0f0f0;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1200" height="600"></canvas>
    <script>

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        window.onload = init;
        
        var panning = false;
        var lastMousePos = {x:0,y:0};
        var cameraOffset = {x:0,y:0};
        var position = [{x:400,y:500}];
        var level = [1];
        var resources = [0];
        var currCosts = [[[0,10]]];
        var scaling = [[[0,"+10"]]];

        var nodeSize = 50;

        var ticks = 0;
        var tickCalc = 60;

        
        function init() {
            window.requestAnimationFrame(draw);
        }
        
        function draw() {
            loop();
            window.requestAnimationFrame(draw);
        }
        const rect = canvas.getBoundingClientRect();

        addEventListener('mousemove', function (e) {
            if (panning) {
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const offsetX = mouseX - lastMousePos.x;
                const offsetY = mouseY - lastMousePos.y;

                cameraOffset.x += offsetX;
                cameraOffset.y += offsetY;

                lastMousePos.x = mouseX;
                lastMousePos.y = mouseY;
            };
        });
        
        addEventListener('mousedown', function (e) {
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (e.button == 2 || (e.button == 0 && e.shiftKey)) { // right click (panning)
                console.log("panning");
                panning = true;

                lastMousePos.x = mouseX;
                lastMousePos.y = mouseY;
            }

            if (e.button == 0) {
                console.log(mouseX, mouseY);
                for (let node = 0; node < level.length; node++) {
                    if (Math.abs(mouseX - position[node].x) <= nodeSize/2 
                     && Math.abs(mouseY - position[node].y) <= nodeSize/2) {
                        nodeClicked(node);
                    }
                }
            }
        });

        addEventListener('mouseup', function (e) {
            if (panning) { // right click (panning)
                console.log("stopped panning")
                panning = false;
            }
        });
    
        addEventListener('keyup', function (e) {
            // console.log(e);
            if (e.key == "Shift" && panning) {
                console.log("stopped panning")
                panning = false;
            }
            if (e.key == "p") {
                console.log(cameraOffset);
            }
        });


        function loop() { // main game loop
            render();
            drawUI();
            calculate();
        }

        function render() { // rendering 
            clearCanvas();
            for (let node = 0; node < level.length; node++) {
                ctx.fillStyle = 'green';
                ctx.fillRect(position[node].x + cameraOffset.x - nodeSize/2, 
                    position[node].y + cameraOffset.y - nodeSize/2, nodeSize, nodeSize);
                ctx.fillStyle = 'black';
                ctx.font = '14px Arial';
                ctx.fillText("Lv." + level[node], position[node].x + cameraOffset.x - nodeSize/4, position[node].y + cameraOffset.y);
                ctx.fillText("Cost: " + currCosts[node], position[node].x + cameraOffset.x - nodeSize/4, position[node].y + cameraOffset.y + 10);
            }
            // ctx.fillRect(cameraOffset.x, cameraOffset.y, 50, 50);
            // ctx.fillStyle = 'black';
            // ctx.fillRect(400, 500, 5, 5);
        }

        function drawUI() {
            ctx.fillStyle = 'black';
            ctx.font = '30px Arial'
            for (let i = 0; i < level.length; i++) {
                if (i == 0) {
                    ctx.fillText("Basic: " + resources[i], 20, 50);
                }
            }
        }


        function nodeClicked(node) {
            if (attemptUpgrade(node)) {
                console.log("Upgraded node " + node + ".");
                level[node] += 1;
                
                // change costs here 
                for (let i = 0; i < currCosts[node].length; i++) {
                    resources[currCosts[node][i][0]] -= currCosts[node][i][1];
                    for (let groups = 0; groups < scaling[node].length; groups++) {
                        curr = scaling[node][groups][1].split(" ")
                        for (let group = 0; group < curr.length; group++) {
                            console.log(currCosts[node][group], curr, curr[group], curr[group][0]);
                            if (curr[group][0] === "+") currCosts[node][i][1] += Number(curr[group].substr(1));
                            if (curr[group][0] === "*") currCosts[node][i][1] *= Number(curr[group].substr(1));
                            if (curr[group][0] === "^") currCosts[node][i][1] = Math.pow(resources[currCosts[node][i][0]], Number(curr[group].substr(1)));

                        }
                    }
                }



            } else console.log("Could not afford!");
        }

        function canAfford(node) {
            for (let i = 0; i < currCosts[node].length; i++) {
                if (resources[currCosts[node][i][0]] < currCosts[node][i][1]) return false;
            }
            return true;
        }

        function attemptUpgrade(node) {
            if (level[node] < 1) return false;
            return canAfford(node);
        }


        function calculate() {
            if (ticks++ >= tickCalc) {
                ticks -= tickCalc;
                for (let i = 0; i < level.length; i++) {
                    resources[i] += level[i];
                }
            }
        }

        // Function to clear canvas
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }



    </script>
</body>
</html>